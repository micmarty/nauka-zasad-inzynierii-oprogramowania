13
{
	#2
	{
		G³owne obszary IO
		!attachment130!
	}

	#3
	{
		Obszary -
		
		Proces pozwala posk³adaæ poszczególne obszary IO
		w sesown¹ ca³oœæ
		
		Podejœcie "na ¿ywio³": cowboy coding, code & fix
		Wtedy wyst¹pi¹ takie problemy jak:
		- konflikty, nieporozumienia w pracy zespo³owej
		- problemy z komunikacj¹ z klientem
		- kijowa jakoœæ kodu i produktu	
	}

	#4
	{
		Modele vs Metodyki -> w nastepnym wyk³adzie jest opisane
		modele -> ogólne, metodyki -> konkretne
	}

	Modele cyklu ¿ycia:
	#5
	{
		Klasyczny model kaskadowy, waterfall:
		
		* Poszczególne etapy s¹ odseparowane i odzwierciedlaj¹ poszczególne
			etapy obszary IO(ten obrazem z za³¹cznika, takie kó³ka w warstwach)

		* W ka¿dym etapie wytwarzamy ca³y system

		* Etapy s¹ sekwencyjnie(trzeba skonczyc poprzedni zeby isc do nastepnego)

		* Jeœli popelni sie b³¹d trzeba wróciæ tam gdzie wyst¹pi³ i 
			przejsc wszystkie posrednie etapy raz jeszcze


			Zalety:
			+ ³atwo skonstruowany/ prosty w t³umaczeniu
			+ obejmuje wszystkie obszary IO, jest systematyczny
			+ wyraŸnie definiuje etapy(mo¿na wprowadziæ milestony, by œledziæ postêpy)
			+ mo¿na roz³o¿yæ pracê w czasie dla poszczególnych ról
				(programista pracuje g³ównie w implementacji, a projektant przy projektowaniu)
			+ jest oparty o standard IEEE

			Wady/problemy:
			- zak³ada uchwycenie ca³oœci ju¿ na pocz¹tku(absurd)
			- zak³ada niezmienne wymagania
			- dzia³aj¹cy soft powstaje na koñcu
			- klient mo¿e zwalidowaæ/oceniæ produkt praktycznie dopiero na koñcu
			- b³¹d/zmiana wymaga cofania siê i przechodzenia ponownego
	}

	#9-11
	{
		Modele nieklasyczne:

		Powsta³ przez software crisis
		Mo¿e byæ warty zastosowania:
		- gdy mamy gwarancje niezmiennosci wymgan
		- dobrze znamy ten temat/zagadanienie -> robilismy podobne projekty


		Przyk³¹dowe modele:

		+ Model V
		!attachment103!

		-----------------																						-----------------------		
		| Planowanie	|																						|Testy akceptacyjne	  |
		| (i analiza	|	<------------------------------------------------------------------------------>	|					  |
		| biznesowa)	|																						-----------------------				
		-----------------																												

						-----------------															-------------------------
						| Analiza		|	<------------------------------------------------>		|	Testy systemowe		|
						-----------------															-------------------------


								-----------------											-------------------------
								| Projekt		|	<---------------------------------->	| Testy integracyjne	|
								| architektury	|											-------------------------
								-----------------

										-----------------						---------------------
										| Projekt		|						| Testy jednostkowe	|
										| szczegó³owy	|	<---------------->	|					|
										-----------------						---------------------

														--------------------------
														|	Implementacja		 |
														--------------------------



						POMIEDZY s¹ zabiegi PROJAKOSCIOWE: inspekcje, przegl¹dy, formalne zatwierdzenia!!!!!!

			Zalety modelu V:
			+ przenosi zalety klasycznego(czyli ³atwy, systematyczny)
			+ ukierunkowany na wysok¹ jakoœæ, przez liczne zabiegi projakosciowe pomiedzy etapami
			+ przez iloœæ testów jest niskie ryzyko krytycznych b³êdów

			Wady:
			- przenosi wady modelu klasycznego(zak³ada stabilne wymagania, nie lubi zmian, produkt na koncu)
			- duzy narzut finansowy i czasowy przez testy
			- duzo dokumentacji
			- trzeba sie wracac przy zmianach + modyfikowac napisane testy
		
		(opisane poŸniej)
		+ Model przyrostowy
		+ Model prototypowy
		+ Model spiralny

	}

	#12
	{
		Podejœcie iteracyjne
		
		- kilka iteracji, zamiast jednego przebiegu (np. w kaskadowym)
		- ka¿da iteracja daje jak¹œ rozwiniêt¹ wersjê produktu
		
		Zalety:
		+ feedback od klienta jest du¿o czêstszy
		+ developerzy ucz¹ siê na b³êdach i lepiej rozumiej¹ problem(rozwijaj¹ funkcjonalnoœæ kilkukrotnie)
		+ b³êdy z iteracji na iteracjê s¹ ³atane

		W specyfikacji RUP wygl¹da tak:
		!attachment104!
	}

	#13
	{
		dodawanie kolejnej porcji funkcjonalnoœci 
			-> model przyrostowy

		wizualizacja wymagañ, lepsze skminienie problemu 
			-> model prototypowy

		zaadresowanie/wykrycie i ominiêcie ryzyka 
			-> model spiralny
	}

	#14
	{
		Model przyrostowy:
		
		To rodzaj podeœjcia iteracyjnego.
		Po prostu celem kolejnych iteracji jest dodanie porcji funkcjonalnosci,
		czyli tworzenie przyrostu


		Algorytm:
		1. Ustalenie zakresu i architektury systemu
		
		2. Specyfikacja (przyrostu)
		3. Projekt i implementacja (przyrostu)
		4. Testowanie i integracja (przyrostu)
		5. Walidacja (i wdro¿enie -> jeœli to ostatni przyrost)
		
		if(skoñczone)
			6. Ukoñczony system
		else
			6. Kolejny przyrost
			goto 2.

		!attachment105!

		Ten model mozna odwzorowaæ na schemacie modelu KLASYCZNEGO
		!attachment106!
	}

	#16
	{
		Przyrost a budowa systemu
		W modelu klasyczym mamy 100% systemu ukoñczone w 60%
		W modelu przyrostowym mamy 60% systemu ukoñczone w 100%
		!attachment107!
	}

	#17
	{
		Ad #14 - model przyrostowy

		Zalety:
		+ zmiany s¹ ³atwiejszy do wprowadzenia
		+ omijamy big bang problem
		+ ci¹g³a mo¿liwoœæ poprawy projektu
		+ pozwala lepiej oceniæ projekt, d³u¿ej dopieszcza siê elementy
		+ na poziomie przyrostu mamy zawsze stabilosc wymagañ

		+ klient nie musi dawac wszystkich ¿¹dañ od razu(wystarczy zarys)
		+ ka¿dy przystost -> nowa funkcjonalnoœæ
			(namacalna rzecz to przetestowania wraz z systemem ktory juz dziala)
		+ wiêksze zaanga¿owanie u¿ytkowników w proces rozwoju


		Wady:
		- mo¿na go stosowaæ raczej tylko w systemach, które
			da siê zdekomponowaæ na czêœci i podsystemy)
		- d³u¿ej dochodzi siê do finalnego produktu(w porownaniu z bezb³êdnym klasycznym)
		- mo¿e siê okazaæ, ¿e pocz¹tkawa analiza nie jest ju¿ wystarczaj¹ca w dalszych etapach
	}

	#18
	{
		Model prototypowy:

		To te¿ podejœcie iteracyjne(tak samo jak przyrostowy)
		
		PROTOTYPY DO WYRZUCENIA:(I termin 2017)
		- model papierowy -> bazuje na rysunkach interfejsu(jakieœ painty takie)
		- model symulowany -> analityk odgrywa role ssytemu i mowi userowi co zrobilby system przy konkretnej akcji
		- model programowy -> program napisany tylko do demka(prosty interfejs i podstawowa funkcjonalnosc)

		inne modele(juz nie do wyrzucenia):
		- model ewolucyjny -> jest to system docelowy wykonany czêœciowo. 
								Zawiera juz w sobie podstawowe funkcjonalnoœci
								Ale ten prototyp bedzie rozszerzany a¿
								do pe³nej wersji systemu docelowego
		
		Pojêcie dodatkowe:
			prototypowanie konstrukcji -> proof of concept


		Zalety:
		+ zwiekszenie zaangazowania udzia³owców w tworzeniu i podejmowaniu decyzji
		+ lepsze dopasowanie systemu do potrzeb klienta(walidacja)
		+ pozwala lepiej zrozumieæ potrzeby
		+ poprawia cechy jakoœciowe:
			- ³atwoœæ u¿ycia, ergonomia
			- utrzymywalnoœæ, jakoœæ konstrukcji

		Wady/problemy:
		- budowa prototypu to dodatkowe koszty i czas
			szczególnie jeœli prototyp bêdzie do wyrzucenia
		- projektant mo¿e z przyzwyczajenia iœæ na ³atwizne i kopiowaæ elementy z prototypu
			do systemu docelowego(co mo¿e zaburzyæ porz¹dane wymagania jakoœciowe)
		- klient myœli, ¿e prototyp jest juz dzia³aj¹cym systemem i nie rozumie, czemu trzeba go porzuciæ
			i zacz¹æ od nowa
	}

	#25
	{
		Model spiralny:

		Jedna z pierwszych podjeœæ iteracyjnych, oparta na ryzyku

		Planowanie | Analiza ryzyka
				   |
		---------------------------> rozmiar systemu, koszt
		Ocena	   | Wytwarzanie
				   |


		spirala zaczyna sie od planowania, koñczy na ocenie


		Podstawowe cechy:
		- zmniejsza ryzyko
		- cykliczne fazy wytwarzania, bior¹ pod uwagê ocenê uzytkownika i  walidacjê
		- Najbardziej ogólny: miesci w sobie inne modele jako specjalne przypadki
		- Przydatny dla projektów obarczonych DU¯YM RYZYKIEM

		Pomaga nad¹¿aæ za konkurencj¹

		Zalety:
		+ minimalizujemy ryzyko, badamy i oceniamy jego wp³yw
		+ jako, ¿e jest iteracyjny to elastyczny do zmian
		+ szybko wykrywane i rozwi¹zane TRUDNE problemy i wyzwania

		Wady:
		- Skomplikowany do t³umaczenia
		- duzy koszt zarz¹dzania ryzykiem
		- duzy czas uzyskania rezultatu koñcowego
		- przydatny w³aœciwie dla duzych organizacji i projektów

	}	


	#26
	{
		Koniec podstawowych modeli


		NAJCZÊSTSZE PODEJŒCIE:

		iteracyjne przyrostowo-ewolucyjne:
			wydziela przyrosty(powi¹zane funkcje pakujemy w podsystem)
			przyrosty podlegaj¹ ewolucji(na bazie feedbacku klienta)
			kazda iteracja to przyrost i udoskonalanie obecnych rzeczy

	}

	#30
	{
		Inne modele


		+ CBD - Component Based Development
			Komponentowy model wytwarzania
			Dla systemów korzystaj¹cych z gotowych komponentów(COTS - commercial of the shelf)
			Nie robimy od nowa, tylko sk³adamy z klocków, ale wymagaj¹ one wyboru do potrzeb i dostosowania

		+ Ponownej in¿ynierii(re-engineering)
			Rozk³adamy istniej¹cy by móc stworzyæ nowy
			Mo¿e nie byæ dokumentacji(analiza starego kodu lub dekompilacja jeœli go nie mamy)
			
			Dwa trójk¹ty prostok¹tne:
			Wspinamy siê i schodzimy

			Poziomy od do³u: Implementation, Design, Requirements, Conceptual

		+ Przekszta³cenia formalne(transformational development)
			Budowa reprezentacji systemu przy u¿yciu modeli matematycznych,
			przekszta³canie do kolejnych form, a¿ do finalnego etapu jakim jest pisanie kodu

			Stosowane w systemach krytycznych(w¹skie dziedziny raczej -> systemy czasu rzeczywistego itd)

		+ MDD - Model Driven Development
			Tez przekszta³cenia ale niekoniecznie formalne(matematyczne)

			CIM - Computation Independent Model -> modelowanie biznesowe
			PIM - Platform Independent Model -> abstrakcja biznesowa jako zestaw funkcjonalnoœci 
			PSM - Platform Specific Model -> model architektoniczny, zale¿ny od platformy i technologii
	}

	#36
	{
		Wybór modelu powinien zale¿eæ od:
		- stabilnoœci wymagañ
		- œwiadomoœci udzia³owców,
		- mo¿liwoœciach dekompozycji systemu
		- u¿ywanie niepe³nego systemu
		- itd.

		Trzeba dobieraæ go wedle przedsiêwziêcia i specyfiki problemu
		S¹ w koñcu abstrakcj¹, czasem siê ³¹cz¹
		
		np.
		prototypowanie do doprecyzowania wymagañ a potem wio na przyrostowym
		spiralny przy ryzyku a potem wio na komponentach
	}
}